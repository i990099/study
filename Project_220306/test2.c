#include<stdio.h>



struct Test {

	int Num;
	char* pcName;
	short sData;
	char cha[2];
	short sBa[4];

}* p;
//假设 p的值为0x100000 如下表达式的值分别为多少
//已知结构体 Test类型的大小是 20个字节
int main() {

	//p = (struct Test*)0x100000; //初始化地址
	//printf("%p\n",p+0x01);  //0x100014    1表示的是一个指针类型的字节长度 p是结构体指针类型 
	////1 表示一个结构体字节的长度也就是20个字节长度
	//printf("%p\n", (unsigned long)p + 0x01);//将p的值0x100000强转成long类型的数值也就是1048576+1=1048577
	////1048577 转换成16进制就是  0x100001
	//printf("%p\n", (unsigned int*)p + 0x01);//将p强转成int* 类型的数值也就是0x100000+1步距=0x100004


	//int a[4] = { 1,2,3,4 };
	//int* ptr1 = (int*)(&a + 1);
	//int* ptr2 = (int*)((int)a+1); //首元素地址加了一个字节长度 小端存储原则 
	////比如0x100001~ 0x100004存储的是元素 1 也就是 01 00 00 00
	//// 0x100005~ 0x100008 存储的是元素 2 也就是      02 00 00 00
	////a的地址是0x100001加一个字节是0x100002 
	////*ptr2 读取4个字节也就是 0x100002~0x100005  00 00 00 02  小端存储也就是0x02000000
	//printf("%x  %x\n",ptr1[-1],*ptr2);// 4    0x02000000


	//int a[3][2] = { (0,1),(2,3),(4,5) };// 逗号表达式  0,1取1  2,3取3  4,5取5    相当于{1,3,5 }
	//int* p;
	//p = a[0];//第一行的一维数组的地址 也是一维数组的首元素地址
	//printf("%d\n", p[0]);//取出一维数组的首元素 也就是 1


	//int a[5][5];
	//int(*p)[4];//相当于每行有4列的一个二维数组
	//p = a;

	////a[4][2]表示第5行第3列 换算成一维数组也就是第23个元素
	////p[4][2] 表示第5行第3列 相当于数组a的第 (4x4+3)/5  相当于a数组的第4行第4列 换算成一维数组也就是第19个元素
	////a数组的第4行第4列 减去 a数组的第5行第3列  19-23 =-4个元素  -4换算成 地址是 FFFFFFFC （-4的补码）
	//printf("%p  %d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);// FFFFFFFC  -4


	//int aa[2][5] = {1, 2, 3, 4, 5, 6, 7, 8, 8, 10};

	//int* ptr1 = (int*)(&aa + 1);  //跨过了一个 10个元素的长度 到了 元素 10 后面一个的地址
	//int* ptr2 = (int*)(*(aa+1));//跨过了5个元素的长度到 6 这个元素的地址

	//printf("%d  %d\n",*(ptr1-1), *(ptr2 - 1));// 10    5




	//char* a[] = {"work","at","alibaba"};
	//char** pa = a;
	//pa++;//跳过了一个char* 类型的大小指向下一个char* 类型 也就是跳过了 4个字节的地址
	//printf("%s\n", *pa);// at

	char* c[] = {"ENTER","NEW","POINT","FIRST"};

	char** cp[] = {c+3,c+2,c+1,c};

	char*** cpp = cp;

	printf("%s\n",**++cpp);//cpp指向cp数组元素 c+3 处的地址 ++cpp指向cp数组元素 c+2处 的地址类型是char***， 
	// *++cpp 拿到cp数组元素c+2的值也就是指针数组 c 中第三个元素 "POINT"的地址 类型是char** 
	// **++cpp 就是对 "POINT"的地址解引用  拿到   "POINT" 首元素 P 的地址 类型是char*  最终打印  POINT
	printf("%s\n", *--*++cpp+3);//此刻cpp指向的是cp数组元素 c+2 处的地址 ++cpp 指向cp数组元素 c+1 处的地址类型是char***
	// *++cpp 拿到cp数组元素 c+1 这个值类型是char**， 
	// --*++cpp 对 c+1进行减法运算  c+1-1 = c  也就是 指针数组 c 中首元素"ENTER"的地址 类型是char**
	// *--*++cpp 对首元素"ENTER"的地址解引用拿到 "ENTER" 首元素 E 的地址，
	// *--*++cpp+3 首元素 E 的地址往后移动三个元素步距也就是  T后面 元素 E 的地址类型是char*  最终打印  ER
	printf("%s\n", *cpp[-2]+3);//此刻cpp指向的是cp数组元素 c+1处的地址 ，
	// cpp[-2] == *(cpp-2) 对指向cp数组元素 c+3 处的地址解引用拿到 元素 c+3 的值 类型是char**
	// *cpp[-2] 表示对指针数组 c 中 第四个元素 "FIRST" 的地址 解引用 拿到 首元素 F 的地址 类型是 char**  
	// *cpp[-2]+3 表示对 首元素 F 的地址进行移动三个元素的步距 指向 S 的地址类型是 char*  最终打印 ST
	printf("%s\n", cpp[-1][-1]+1);//因为上一个cpp是做的减法运算而不是自减运算所以此刻 cpp指向的还是cp数组中元素 c+1处的地址类型是char***
	// cpp[-1]==*(cpp-1) 对 cp数组中元素 c+1处的地址做减一操作指针向前移动一个char***步距之后指向cp数组元素c+2处的地址然后 解引用 拿到元素 c+2  类型是char**
	// cpp[-1][-1] == *(*(cpp-1)-1) 对 元素 c+2 先做减一操作 c+2-1 = c+1  也就是数组 c 中第二个元素 "NEW" 的地址，
	// 然后对元素 c+1也就是指针数组 c 中第二个元素 "NEW" 的地址进行解引用， 解引用之后就是拿到 首元素 N 的地址 类型是char*
	// cpp[-1][-1]+1 表示 对字符数组NEW 首元素进行 移动一个char*步距的操作 指向E处的地址类型是char*  最终打印 EW




	return 0;
}